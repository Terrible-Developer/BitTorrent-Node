#+TITLE: Tracker
#+DESCRIPTION: file related to the torrent tracker
#+PROPERTY: :tangle "./tracker.js"

* Explanation
There is no explanation so far, this is just a placeholder

* Code
** Imports
#+BEGIN_SRC js :tangle yes
import dgram from 'dgram';
import { Buffer } from 'buffer';
import { urlParse } from 'url';
import crypto from 'crypto';
import { genInfoHash, getTorrentSize } from './torrent-handler.js';
import { genPeerId } from './generic-utils.js';
#+END_SRC

** Methods
*** udpSend
Sends a message through the udp socket
#+BEGIN_SRC js :tangle yes
const udpSend = (torrent, message, rawUrl, callback) => {
    const url = urlParse(rawUrl);
    socket.send(message, 0, message.length, url.port, url.host, callback);
};
#+END_SRC
*** responseType
Interprets the response type
#+BEGIN_SRC js :tangle yes
const responseType = response => {

};
#+END_SRC

*** buildConnectionRequest
Builds the connection request
#+BEGIN_SRC js :tangle yes
const buildConnectionRequest = () => {
    //1. buffer allocation
    const buf = Buffer.alloc(16);

    //2. connection_id
    buf.writeUInt32BE(0x417, 0);
    buf.writeUInt32BE(0x27101980, 4);

    //3. action type
    buf.writeUInt32BE(0, 8);

    //4. transaction_id
    crypto.randomBytes(4).copy(buf, 12);

    return buf;
};
#+END_SRC

*** parseConnectionResponse
Parses the response to the connectionRequest
#+BEGIN_SRC js :tangle yes
const parseConnectionResponse = response => {
    return {
        action: response.readUInt32BE(0),
        transactionId: response.readUInt32BE(4),
        connectionId: response.slice(8)
    };
};
#+END_SRC

*** buildAnnounceRequest
Builds the announce request
#+BEGIN_SRC js :tangle yes
const buildAnnounceRequest = (connectionId, torrent, port = 6881) => {
    //1. allocate buffer
    const buf = Buffer.allocateUnsafe(98);

    //2. connection_id
    connectionId.copy(buf, 0);

    //3. action
    buf.writeUInt32BE(1, 8);

    //4. transaction_id
    crypto.randomBytes(4).copy(buf, 12);

    //5. info hash
    genInfoHash(torrent).copy(buf, 16);

    //6. peer id
    genPeerId().copy(buf, 36);

    //7. downloaded
    Buffer.alloc(8).copy(buf, 56);

    //8. left
    getTorrentSize(torrent).copy(buf, 64);

    //9. uploaded
    Buffer.alloc(8).copy(buf, 72);

    //10. event
    buf.writeUInt32BE(0, 80);

    //11. ip address
    buf.writeUInt32BE(0, 80);

    //12. key
    crypto.randomBytes(4).copy(buf, 88);

    //13. num_want
    buf.writeUInt32BE(-1, 92);

    //14. port
    buf.writeUInt32BE(port, 96);

    return buf;
};
#+END_SRC

*** parseAnnounceResponse
Parses the response to the announce request
#+BEGIN_SRC js :tangle yes
const parseAnnounceResponse = response => {

};
#+END_SRC

*** getPeers
Get a list of the torrent peers
#+BEGIN_SRC js :tangle yes
const getPeers = (torrent, callback) => {
    const url = urlParse(torrent.announce.toString("utf8"));
    const socket = dgram.createSocket('udp4');

    udpSend(socket, buildConnectionRequest(), url);

    socket.on('message', response => {
        if(responseType(response) === 'connect'){
            const connectionResponse = parseConnectionResponse(response);
            const announceRequest = buildAnnounceRequest(connectionResponse.connectionId);
            udpSend(socket, announceRequest, url);
        }
        else if(responseType(response) === 'announce'){
            const announceResponse = parseAnnounceResponse(response);
            callback(announceResponse.peers);
        }
    });
};
#+END_SRC

** Exports
#+BEGIN_SRC js :tangle yes
export {
    getPeers
};
#+END_SRC

* Reference
** Torrent Requests
The requests need to be buffers with specific values in certain positions (for more info, see http://www.bittorrent.org/beps/bep_0015.html).

** getPeers
Get url and create udp socket; send connection request with udpSend();
On receiving message, check the type with responseType() and handle it accordingly;
If the message type is connect, then the connection response is parsed with parseConnectionResponse(), the request is built with buildAnnounceRequest(), and the message request is sent with udpSend();
If the message type is announce, then the response is parsed with parseAnnounceResponse(), and the callback function is called.

** buildConnectionRequest
This is the connect request
The buffer's first 8 bits (from position 0 to position 7) are a 64-bit integer with the value of 0x41727101980;
the next 4 bits (from position 8 to 11) must be an 32-bit integer describing the action (in this case, connect, the value is 0);
then, the final 4 bits (from position 12 to 16) form the transaction id, a 32-bit integer with whatever random value the id will be.
#+BEGIN_SRC dot
Offset  Size            Name            Value
0       64-bit integer  protocol_id     0x41727101980
8       32-bit integer  action          0
12      32-bit integer  transaction_id
16
#+END_SRC
*** 1. buffer allocation
Allocating the 16-bit buffer, the size of the message.
*** 2. connection_id
Creating the connection_id with the value stated by the documentation (0x41727101980). It must be created as two separate 32-bit integers because node doesn't support 64-bit integers.
*** 3. action type
Passing the action type to the buffer (0 in this case, for connect)
*** 4. transaction_id
Since this needs to be a random value, the crypto module can be used. After importing it, and after passing all the other values to the buffer, the random value can be generated with the randomBytes method, specifyng the number of bytes it should return; And then, with the copy method, it is copied to the message buffer, with the offset of 12, setting the starting position

** parseConnectionResponse
Parsing the response to the connect request
Much simpler than creating the request itself, the response is received, and then every part is separated into a property of an object, which is returned.
The response structure is similar to the request (see below), but the action is the first value, then the transaction_id, and then the connection_id.
To separate them easily, the first 4 bytes are read as the action (starting at 0), the following four are read as the transaction_id, and for last, since the connection_id is a 64-bit integer, it's easier to just splice the buffer instead of reading it as two halves and trying to join them afterwards.
#+BEGIN_SRC dot
Offset  Size            Name            Value
0       32-bit integer  action          0 // connect
4       32-bit integer  transaction_id
8       64-bit integer  connection_id
16
#+END_SRC

** buildAnnounceRequest
This is the announce request
It follows the same idea of the connection request, but it has several more values. It is 98 bytes long. It would be too long to explain every part individually, so just check the graph below.

Note: this is the announce request for ipv4 addresses. For ipv6, check the documentation linked in the Torrent Requests section.
#+BEGIN_SRC dot
Offset  Size    Name    Value
0       64-bit integer  connection_id
8       32-bit integer  action          1 // announce
12      32-bit integer  transaction_id
16      20-byte string  info_hash
36      20-byte string  peer_id
56      64-bit integer  downloaded
64      64-bit integer  left
72      64-bit integer  uploaded
80      32-bit integer  event           0 // 0: none; 1: completed; 2: started; 3: stopped
84      32-bit integer  IP address      0 // default
88      32-bit integer  key
92      32-bit integer  num_want        -1 // default
96      16-bit integer  port
98
#+END_SRC
